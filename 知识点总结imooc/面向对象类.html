<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>面向对象类</title>
</head>
<body>
	<script type="text/javascript">
		/**
		 * 类的声明
		 * (1.用构造函数模拟类 2.ES6中class的声明)
		 */
		function Animal(){
			this.name = 'name';
		}
		class Animal2{
			constructor(){
				this.name = 'name';
			}
		}
		/**
		 * 实例化
		 */
		console.log(new Animal(),new Animal2());//如果构造函数没有参数，则new后面的()可以省略

		/**
		 * 1.借助构造函数实现继承
		 * 原理：将父级构造函数的this指向子构造函数的实例上，父级构造函数的属性在子类中也有
		 * (缺点：Parent1原型链上的属性方法并没有被Child1继承)
		 * 优点：可以实现多继承；(子类实例共享父类引用属性; 创建子类实例时，可以向父类传递参数)
		 * 缺点：但是只能继承构造函数中的属性，没办法继承原型对象上的属性；
		 * 		所有继承的属性都是相互独立的，不共享，占内存。
		 * 		(实例并不是父类的实例，只是子类的实例;无法实现函数复用，每个子类都有父类实例函数的副本，影响性能)
		 */
		function Parent1(){
			this.name = 'parent1';
		}
		function Child1(){
			Parent1.call(this);//在子类的构造函数体中执行父类的构造函数，实现继承
			this.type = 'child1';
		}
		console.log(new Child1)
		Parent1.prototype.say = function(){}
		console.log(new Child1(), new Child1().say())
		
		/**
		 * 2.借助原型链实现继承
		 * (缺点：原型链中的原型是所有实例共用的)
		 * 优点：非常纯粹的继承关系，实例是子类的实例，也是父类的实例；
		 * 		父类新增原型方法/原型属性，子类都能访问到；
		 * 		简单，易于实现
		 * 缺点：要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中；？？
		 * 		无法实现多继承；
		 * 		来自原型对象的所有属性被所有实例共享（来自原型对象的引用属性是所有实例共享的）;
		 * 		创建子类实例时，无法向父类构造函数传参;
		 */
		function Parent2(){
			this.name = 'parent2';
			this.play = [1,2,3];
		}
		function Child2(){
			this.type = 'child2'
		}
		Child2.prototype = new Parent2();
		console.log(new Child2)
		console.log(new Child2().__proto__ === Child2.prototype);//相等，即new Child2().__proto__属性引用的是Parent2的实例对象

		var s1 = new Child2();
		var s2 = new Child2();
		console.log(s1.play, s2.play)
		s1.play.push(4)
		console.log(s1.play,s2.play)//都输出[1,2,3,4]
		console.log(s1.__proto__ === s2.__proto__)//相等

		/**
		 * 3.组合继承方式
		 * 缺点：实例化子类时，父级的构造函数执行了两次；
		 * s3的构造函数指向了Parent3()
		 */
		 function Parent3(){
		 	this.name = 'parent3';
		 	this.play = [1,2,3]
		 }
		 function Child3(){
		 	Parent3.call(this)
		 	this.type = 'child3';
		 }
		 Child3.prototype = new Parent3();
		 var s3 = new Child3()//实例化子类时，父级的构造函数执行了两次
		 var s4 = new Child3()
		 s3.play.push(4)
		 console.log(s3.play, s4.play)

		 /**
		  * 4.组合继承的优化1
		  * 缺点：s5的构造函数指向了Parent4()
		  */
		 function Parent4(){
		 	this.name = 'parent4';
		 	this.play = [1,2,3]
		 }
		 function Child4(){
		 	Parent4.call(this)
		 	this.type = 'child4';
		 }
		 Child4.prototype = Parent4.prototype;
		 var s5 = new Child4()
		 var s6 = new Child4()
		 s5.play.push(4)
		 console.log(s5.play, s6.play)
		 console.log(s5 instanceof Child4, s5 instanceof Parent4)
		 console.log(s5.constructor)//指向Parent4构造函数
		 /**
		  * 4.组合继承的优化2
		  */
		 function Parent5(){
		 	this.name = 'parent5';
		 	this.play = [1,2,3]
		 }
		 function Child5(){
		 	Parent5.call(this)
		 	this.type = 'child5';
		 }
		 Child5.prototype = Object.create(Parent5.prototype);
		 Child5.protptype.construcor = Child5;
		 var s7 = new Child5()
		 s7.play.push(4)
		 console.log(s7 instanceof Child5,s7 instanceof Parent5)
		 console.log(s7.constructor)
	</script>
</body>
</html>